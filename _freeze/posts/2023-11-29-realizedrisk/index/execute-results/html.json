{
  "hash": "445147bf6fb1bab267431530951f17d4",
  "result": {
    "markdown": "---\ntitle: \"Simulation of Realized Infection Risk\"\ndescription: \"simulate a probability distribution of risk\"\nauthor:\n  - name: Kayla Kauffman\n    url: https://https://kmkauffm.github.io/\n    orcid: 0000-0002-4897-9428\nformat:\n  html:\n    toc: true\n    toc-location: left\n    message: false\n    warning: false\n    code-fold: true\n    code-tools: true\n    theme: sandstone\nbibliography: references.bib\ndate: 2023-12-15\ncategories: [R, code, simulations] # self-defined categories\nimage: schema.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\nMy research broadly addresses how land use change impact zoonotic disease sharing patterns between wildlife, domestic animals and people. One aspect of this research delves into how well a landscape of risk [@weinstein2018] can be predicted across space and time [@albery2022], and if people that spend more time in areas of high pathogen prevalence on the landscape are more likely to be infected with that parasite. The landscape of risk is the variation in pathogen density or pressure across the landscape, and the underlying environmental characteristics that permit pathogen persistence and onward transmission to susceptible individuals visiting that area (e.g., [@titcomb2021]).\n\nPrior to doing this with actual data I want to set up a simulation so I can figure out some of the methods using a simplified scenario. In particular I am interested in comparing how noise in the dataset due to the variability in individuals home range sizes and susceptibility to infection affect my ability to associate cumulative exposure risk to infection probability. For my purposes here susceptibility encompasses variability in behavior of individuals that influence pathogen exposure, immunological function, genetics, etc [@sweeny2022].\n\n# Risk Map\n\nI am using the elevation raster of Zion National Park included in the `spDataLarge` package as the landscape risk map. The thought behind using this and not simply a simulated raster is to have highly variable patterns and spatial autocorrelation. However to use this, I need the values to fall between 0 and 1. This is what the original maps looks like with the scaled values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## load the data from the spDataLarge package\nriskmap <- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\n## project in utm so easier units for making the simulated tracks\nriskmap <- project(riskmap, \"EPSG:26912\")\n\n## make values [0,1]\nriskmap <- riskmap/max(values(riskmap), na.rm=T)\n\n## most places should be pretty low\n## look at the 'original values'\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(riskmap)) +\n  scale_fill_viridis_c() +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"elevation scaled [0,1]\", title = \"Origional Elevation Map\") +\n  theme(axis.text = element_blank()) # since don't care about location\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nI want the values to be right skewed so that most places are low risk. So I transformed the values to values^3^ in my scaled raster to get the desired distribution of risk (pathogen density) in my risk map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## histogram of value distribution\np1 <- values(riskmap) %>% \n  as.data.frame() %>% \n  filter(is.finite(srtm)) %>% \n  ggplot() +\n  geom_histogram(aes(x=srtm)) +\n  labs(x = \"cell values\", y = \"frequency\", title = \"Origional risk map values [0,1]\")\n\n## add right skew to values so most are low\nriskmap <- riskmap^3\n\n## plots to commpare old and new value distributions\np2 <- values(riskmap) %>% \n  as.data.frame() %>% \n  ggplot() +\n  geom_histogram(aes(x=srtm)) +\n  labs(x = \"cell values\", y = \"frequency\", title = \"Skewed risk map values [0,1]\")\n\n## plot old and new next to each other\np1+p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nTo make things run quickly, I aggregated the risk map so the resolution is lower. Then cropped the map to a squarer area so individuals don't fall outside of the area with values (the grey parts of the map above).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## make resolution lower so things run quickly\nriskmap <- aggregate(riskmap, fact=5, fun=\"mean\")\n\n## make square\ntmp <- vect(ext(riskmap)-1500, crs=crs(riskmap))\nriskmap <- crop(riskmap, tmp)\n\n## plot the new lower resolution map\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(riskmap)) +\n  scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"risk level\", title = \"Risk Map\") +\n  theme(axis.text = element_blank()) # since don't care about location\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n## check the data structure\n# riskmap\n```\n:::\n\n\n\n\n# Single simulation\n\nI am using a single simulation to figure out how to set up the simulation and to outline the process involved in the simulation. Once that is ironed out, I'll put everything into a single function so I can repeat the simulation many times and get confidence intervals for my estimated effects.\n\n## Simulate movement\n\nTo simulate movement of individuals I followed the [`SiMRiv` vignette](https://cran.r-project.org/web/packages/SiMRiv/vignettes/SiMRiv.pdf). I wanted to have two types of movement to use in my simulation. I am calling these:\n\n-   **Simple random walk** - Single-state uncorrelated movement in an homogeneous landscape using Brownian motion [@turchin1998] to make individuals 'vibrate' in place. Movement of only this type is the 'null' state because an individual essentially staying in one place will have an exposure risk equal to their singular location. This state will be used to demonstrate that an individual's probability of infection is proportional to their exposures.\\\n-   **Complex correlated walk** - Multistate correlated movement in a heterogeneous landscape using Levy walk-like movement with two-state movements composed of small random walks and bursts of longer correlated random walks [@reynolds2010]. A heterogeneous landscape is used to makes some areas high resistance, thus the population's movements will look more similar, since most movement will follow low resistance 'paths' (roads), but individuals will still randomly branch off into higher resistance areas.\n\nAn important part of simulating movement is the step length, which need to be relevant to the animal and the resolution of the raster. To limit movement in the simple random walk, make step sizes 1/20th of the resolution of the risk map. Find the resolution of the risk map. The resolution show help with choosing a step length that is relative to the pixel sizes so that individuals can move, but not too much within a given step. Steps of \\~1/10 a pixel seem reasonable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## save cell size\ncell_size = res(riskmap)[1]\n\n## number of steps\nnsteps = 1000\n\n## random walk with step lengths relative to rast resolution\nrand.walk <- state(concentration = 0, #turning angle concentration; 0=random\n                             pwind = perceptualRange(\"gaussian\", # centered on indiv's position\n                                                     cell_size/5), ## radius of perceptual range 1/4 of steplength\n                             steplen = cell_size/20, #maximum step length\n                             name = \"tight_random\") #name of the state\n\n## correlated walk with step lengths relative to rast resolutions\ncorr.walk <- state(concentration = 0.9, #turning angle concentration; 1=straight line\n                             pwind = perceptualRange(\"circular\", # gives equal weight to all pixels centered on current position\n                                                     cell_size*2), ## radius of perceptual range 1/4 of steplength\n                             steplen = cell_size/5, #maximum step length\n                             name = \"correlated\") #name of the state\n\n## using those states make walkers\nrand.walker <- species(states = rand.walk)\n## set up levy walker walk\nlevy.walker <- species(states = c(rand.walk,\n                                  corr.walk),\n                       trans = transitionMatrix(0.05, 0.01)) #probabilities of changing state 1 -> 2 and 2 -> 1\n```\n:::\n\n\n### Simple random walk\n\nI simulated the simple random walks for 100 individuals all starting at randomly selected areas with in an area of interest (aoi). Because individuals can run off the edge of the raster, the starting locations should not be near the edge. The area of interest is the white rectangle, with each point representing an individual's starting location.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## generate random starting points \n### avoid edges by defining area of interest more inside the risk map\n### find bounding box of risk map\naoi <- st_bbox(riskmap)\n### make insto sfc (spatial) object\naoi <- st_as_sfc(aoi)\n### buffer to be 5 cells from edge of riskmap\naoi <- st_buffer(aoi, -cell_size*5)\n\n# aoi <- crop(riskmap, aoi)\n# ggplot() +\n#   stars::geom_stars(data = stars::st_as_stars(riskmap)) +\n#   scale_fill_viridis_c(option = \"H\") +\n#   coord_fixed() +\n#   labs(x=NULL, y=NULL, fill = \"risk level\", title = \"Area of interest for starting locations on Risk Map\") +\n#   theme(axis.text = element_blank()) +# since don't care about location\n#   geom_sf(data = aoi, fill = \"white\", alpha = 0.3, color = \"white\", lwd = 1)\n\nstart_coord <- st_sample(aoi, 100, type = \"random\")\n\n## plot it\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(riskmap)) +\n  scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"risk level\", title = \"Random walk starting locations\") +\n  theme(axis.text = element_blank()) +# since don't care about location\n  geom_sf(data = aoi, fill = \"white\", alpha = 0.3, color = \"white\", lwd = 1) +\n  geom_sf(data = start_coord)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThe random walks for all the individuals look like my intended \"vibrating in place\" outcome, such that individuals will spend all their time in just a few pixels, so theoretically their exposure risk is less variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## need the locations as a nx2 matrix\n# start_coord_mat <- as.matrix(as.data.frame(start_coord, geom=\"xy\"))\nstart_coord_mat <- st_coordinates(start_coord)\n\n## simulate single state walks of 1000 steps\nsim.rw <- list()\nfor (i in 1:100) {\n  ## simulate from location i\n  tmp <- simulate(rand.walker, nsteps,\n                   coords = start_coord_mat[i,])\n  ## save results to a list\n  sim.rw[[i]] <- cbind(tmp[,1], tmp[,2])\n}\n\n## make in to sfc lines\nsim.rw.sfc <- lapply(sim.rw, st_linestring)\nsim.rw.sfc <- st_sf(id = 1:100, geometry = sim.rw.sfc) %>% \n  st_set_crs(st_crs(riskmap))\n\n## plot it\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(riskmap)) +\n  scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"risk level\", title = \"Random walks\") +\n  theme(axis.text = element_blank()) +# since don't care about location\n  geom_sf(data = sim.rw.sfc)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n### Correlated walks\n\nA resistance raster is needed to get correlated (levy walker) walks that are similar between individuals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## basemaps for resistance --NOT using because individual end up in a hairball\n# landcover <- resistanceFromShape(\n# system.file(\"doc/landcover.shp\", package=\"SiMRiv\")\n# , res = 50, field = \"coverclass\", mapvalues = c(\n# \"forest\" = 0.5, \"urban\" = 1, \"dam\" = 0\n# , \"shrubland\" = 0.75), background = 0.95)\n#  \n## river shape is the main resistance, because walks will follow paths\nriver.shape <- sf::st_read(system.file(\"doc/river-sample.shp\", package=\"SiMRiv\"), quiet = T)\n\n## resistence surface\nresistance <- resistanceFromShape(river.shape, #system.file(\"doc/river-sample.shp\", package=\"SiMRiv\"),\n                                       # baseRaster = landcover, ## not using\n                                  res =50, #provide when don't provide basemap\n                                       buffer = 300, field = 0.01,\n                                       background = 0.75, margin = 3000)\n\n## add central area with low resistence so individuals start in roughly the same place\nriver.cent <- st_buffer(st_centroid(st_union(river.shape)), 200)\nresistance <- resistanceFromShape(river.cent, \n                                  baseRaster = resistance, \n                                  buffer = 1000, field = 0, \n                                  background = 1, margin = 3000)\n# buffer here is just some magical function to convert river\n# order into a meaningful value in the [0, 1] range!\n# plot(resistance, axes = F, main=\"resistence raster\")\n# resistance\n```\n:::\n\n\n\n\nThen the resistance raster should be down sampled and moved to the same location as the risk map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## move the resistence 'rivers' to the same location as the risk map\nresistance <- rast(nrows = dim(resistance)[1],\n                   ncols = dim(resistance)[2],\n                   nlyrs = 1, \n                   names = \"resistance\", \n                   extent = st_bbox(aoi),\n                   vals = values(resistance),\n                   crs = crs(riskmap))\n\n## resample to resolution matches riskmap\nresistance <- resample(resistance, riskmap, method = \"rms\")\n\n## make NAs to 1\nresistance[is.na(resistance)] = 1\n\n## plot it\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(resistance)) +\n  scale_fill_steps(breaks = c(0, 0.001, 0.4, 0.6, 0.75, 1),\n                   low=\"white\", high = \"black\") +\n  # scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"resistance\", title = \"Resistance layer\") +\n  theme(axis.text = element_blank()) # since don't care about location\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nAt first I tried using the same random starting locations as above to generate my correlated walks for each individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## simulate single state walks of 1000 steps\nsim.rw <- list()\nfor (i in 1:100) {\n  ## simulate from location i\n  tmp <- simulate(levy.walker, nsteps,\n                  resist = raster(resistance),\n                   coords = start_coord_mat[i,])\n  ## save results to a list\n  sim.rw[[i]] <- cbind(tmp[,1], tmp[,2])\n}\n\n## make in to sfc lines\nsim.rw.bad <- lapply(sim.rw, st_linestring)\nsim.rw.bad <- st_sf(id = 1:100, geometry = sim.rw.bad) %>% \n  st_set_crs(st_crs(riskmap))\n\n## plot it\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(resistance)) +\n  scale_fill_steps(breaks = c(0, 0.001, 0.4, 0.6, 0.75, 1),\n                   low=\"white\", high = \"black\") +\n  # scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"resistance\", title = \"Levy-walker walks - random start locations\") +\n  theme(axis.text = element_blank()) +# since don't care about location\n  geom_sf(data = sim.rw.bad, col=\"red\", alpha=0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\nHowever, to make this more realistic, my correlated walks should also act like individuals following paths then delving off into different areas such as people accessing their crop fields. So instead of using random starting locations, I made the starting locations only be in low resistance areas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## new starting coords in areas of low resistance so don't get stuck\ninit = xyFromCell(resistance, sample(which(values(resistance) == 0), 100, replace=T))\n\n## simulate\nsim.rw <- list()\nfor (i in 1:100) {\n  ## simulate from location i\n  tmp <- simulate(levy.walker, nsteps,\n                  resist = raster(resistance),\n                   coords = init[i,])\n  ## save results to a list\n  sim.rw[[i]] <- cbind(tmp[,1], tmp[,2])\n}\n\n## make in to sfc lines\nsim.rw.levy <- lapply(sim.rw, st_linestring)\nsim.rw.levy <- st_sf(id = 1:100, geometry = sim.rw.levy) %>% \n  st_set_crs(st_crs(riskmap))\n\n## plot it\nggplot() +\n  stars::geom_stars(data = stars::st_as_stars(resistance)) +\n  scale_fill_steps(breaks = c(0, 0.001, 0.4, 0.6, 0.75, 1),\n                   low=\"white\", high = \"black\") +\n  # scale_fill_viridis_c(option = \"H\") +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"resistance\", title = \"Levy-walker walks\") +\n  theme(axis.text = element_blank()) +# since don't care about location\n  geom_sf(data = sim.rw.levy, col=\"red\", alpha=0.25)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n## Exposure risk\n\nFor each individual I calculate their utilization distribution based purely on the proportion of points in each cell (density). For real movement data using more accurate estimates of utilization distributions such as kernel density, Brownian bridge movement models, etc. However, those methods are slow.\n\nTo figure out how to do this, I first tried it out with just one individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## which individual (1-100)\nwho = 1\n## kernel density estimate\nkde.trial <- terra::rasterize(st_cast(sim.rw.levy[who,], \"MULTIPOINT\"), riskmap, fun = \"length\", background = 0)/nsteps\n\nif(sum(values(kde.trial), na.rm=T) != 1){\n  stop(\"the sum of the density should be equal to 1\")\n}\n```\n:::\n\n\n\n\nTo see what that looks like, for the single individual I cropped to just the immediate area that individual used the plot their density estimate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## crop to area where the individual was so not tiny\nkde.sm <- terra::crop(kde.trial, st_buffer(sim.rw.levy[who,], 2000))\n\n## similarly crop riskmap to same area\nrisk.sm <- crop(riskmap, st_buffer(sim.rw.levy[who,], 2000))\n\n## plot traj and kde\nggplot()+\n  stars::geom_stars(data = stars::st_as_stars(kde.sm)) +\n  scale_fill_viridis_c(option=\"A\", direction = -1) +\n  coord_fixed() +\n  labs(x=NULL, y=NULL, fill = \"kde\", title = \"Density raster of one individual\") +\n  theme(axis.text = element_blank()) +# since don't care about location\n  geom_sf(data = sim.rw.levy[who,])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nNow I want to calculate the exposure risk for each individual $k$ in each pixel ($i$) as a function of the time they spend in that pixel and the risk of exposure in that pixel.\n\n$$\nExposure_{ki} = kde_i*risk_i\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## calculate risk \nkde.risk <- kde.sm*risk.sm\n\n## plots to demo\np1 <- ggplot()+\n  tidyterra::geom_spatraster(data=risk.sm) +\n  scale_fill_viridis_c(option=\"A\", direction = -1) +\n  labs(title = \"Landscape risk\", fill = \"risk\") +\n  theme(legend.position = \"bottom\", axis.text = element_blank(),\n        legend.direction = \"horizontal\")\np2 <- ggplot()+\n  tidyterra::geom_spatraster(data=kde.sm) +\n  scale_fill_viridis_c(option=\"A\", direction = -1) +\n  labs(title = \"KDE of Individual use\", fill = \"use\") +\n  theme(legend.position = \"bottom\", axis.text = element_blank(),\n        legend.direction = \"horizontal\")\np3 <- ggplot()+\n  tidyterra::geom_spatraster(data=kde.risk) +\n  scale_fill_viridis_c(option=\"A\", direction = -1) +\n  labs(title = \"Infection probability\", fill = \"probability\") +\n  theme(legend.position = \"bottom\", axis.text = element_blank(),\n        legend.direction = \"horizontal\")\np1 + p2 + p3\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\nTherefore for each individual $k$ their cumulative 'exposure risk' the sum of all their exposures in pixels, where $i$ is $1:n_{pixels}$: $$\nExposure_k = \\sum{kde_i*risk_i}\n$$\n\nTo calculate the cummulative exposure risk for all individuals, I used a function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n## make a function\nmeasure_risk <- function(walker, riskmap, nsteps){\n  \n  ## convert from lines to points\n  pts <- st_cast(walker, \"MULTIPOINT\")\n  \n  ## dataframe with any attributes (just IDs)\n  df <- pts %>% st_drop_geometry() %>% as.data.frame()\n  \n  pts <- vect(pts)\n\n  ## for each individual rasterize their points so have sum of points in each pixel\n  ## this is not working using the stars::st_rasterize, or the terra::rasterize -- both return one object of all individuals, not an obj per indiv\n  ## also tried using apply, lapp, and app with those terra::rasterize\n  kde <- c()\n  for(i in 1:nrow(pts)){\n    kde[[i]] <- terra::rasterize(pts[i,], riskmap, fun = \"length\", background = 0)/nsteps\n  }\n\n  ## multiply time in cell (kde) * cell's risk\n  kde.risk <- lapply(kde, function(i) i*riskmap)\n  \n  ## sum of values in each layer are individual's risk\n  indiv.risk <- lapply(kde.risk, function(i) sum(values(i), na.rm=T))\n  \n  df$exp_risk <- unlist(indiv.risk)\n  \n  return(df)\n}\n```\n:::\n\n\nI found the cummulative expsoure risk for each individual using the function.\n\n\n::: {.cell}\n\n:::\n\n\nThe distribution of values in the random walkers is the range of the map, which is expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## look at some of the values\n# indiv.risk.rw %>% head() %>% knitr::kable(title = \"Cummulative exposure risk (`exp_risk`) by individual (`id`)\")\nindiv.risk.rw %>% \n  ggplot()+\n  geom_histogram(aes(x = exp_risk)) +\n  labs(x = \"risk\", title = \"Distribution of individual's cumulative exposure risk - Random walks\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nThe distribution of values in the correlated walkers is less then the range of the map, which is also expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# indiv.risk.levy %>% head()\nindiv.risk.levy %>% \n  ggplot()+\n  geom_histogram(aes(x = exp_risk)) +\n  labs(x = \"risk\", title = \"Distribution of individual's cumulative exposure risk - Levy-walker walks\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Assisgn susceptibility\n\nIndividuals should have variable susceptibility so that not everyone's probability of infection equals their risk sum. This is adding noise to the data. I want to compare the randomly assign susceptibility to a fixed susceptibility for each simulation. The fixed susceptibility is just the average susceptibility of all individuals in that round of the simulation. For this simulation I am assigning susceptibility randomly using a uniform distribution between 0.7 and 0.9. and the fixed susceptibility with the average of the random susceptibility values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n## susceptibility is variable between individuals\nsusceptibility = runif(100, 0.7, 0.9)\nmean_suscept = mean(susceptibility)\n```\n:::\n\n\nThe probability of infection is a product of the individuals exposure risk and susceptibility.\n\n\n::: {.cell layout-ncol=\"2\" tbl-cap='Infections in Random Walkers' tbl-subcap='[\"exposure*susceptibility\",\"exposure*avg susceptbility\"]'}\n\n```{.r .cell-code}\n## make a dataframe for the outcomes --- random walkers\nrw_risk <- cbind(indiv.risk.rw,\n                 data.frame( susceptibility = susceptibility)) %>%\n  rowwise() %>% \n  ## predict infections based on exposure risk\n    mutate(infected_es = rbinom(1, 1, exp_risk * susceptibility ), # sum(exp_risk * susceptibility)\n           infected_e = rbinom(1, 1, exp_risk * mean_suscept)) # sum(exposure risk) alone\n\n## see how many people infected  = 1\nrw_risk %>% count(infected_es) %>% knitr::kable()\n```\n\n::: {.cell-output-display}\n| infected_es|  n|\n|-----------:|--:|\n|           0| 73|\n|           1| 27|\n:::\n\n```{.r .cell-code}\nrw_risk %>% count(infected_e) %>% knitr::kable()\n```\n\n::: {.cell-output-display}\n| infected_e|  n|\n|----------:|--:|\n|          0| 74|\n|          1| 26|\n:::\n:::\n\n::: {.cell layout-ncol=\"2\" tbl-cap='Infections in Correlated Walkers' tbl-subcap='[\"exposure*susceptibility\",\"exposure*avg susceptbility\"]'}\n\n```{.r .cell-code}\n## make a dataframe for the outcomes --- levy walkers\nlevy_risk <- cbind(indiv.risk.levy,\n                 data.frame( susceptibility = susceptibility)) %>%\n  rowwise() %>% \n  ## predict infections based on exposure risk\n    mutate(infected_es = rbinom(1, 1, exp_risk * susceptibility ), # sum(exp_risk * susceptibility)\n           infected_e = rbinom(1, 1, exp_risk * mean_suscept)) # sum(exposure risk) alone\n\n## see how many people infected  = 1\nlevy_risk %>% count(infected_es) %>% knitr::kable()\n```\n\n::: {.cell-output-display}\n| infected_es|  n|\n|-----------:|--:|\n|           0| 65|\n|           1| 35|\n:::\n\n```{.r .cell-code}\nlevy_risk %>% count(infected_e) %>% knitr::kable()\n```\n\n::: {.cell-output-display}\n| infected_e|  n|\n|----------:|--:|\n|          0| 65|\n|          1| 35|\n:::\n:::\n\n\n## Results\n\nIf the map worked, then exposure risk should predict infection in the random walkers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(rw_risk, aes(x=exp_risk, y = infected_es))+\n  geom_point(aes(col=factor(infected_es))) +\n  geom_smooth(method=\"lm\") +\n  scale_y_continuous(breaks = c(0, 1)) +\n  labs(x = \"exposure risk\", y = \"infected\", col = \"infected\", subtitle = \"exposure * susceptbility\")\n\np2 <- ggplot(rw_risk, aes(x=exp_risk, y = infected_e))+\n  geom_point(aes(col=factor(infected_e))) +\n  geom_smooth(method=\"lm\") +\n  scale_y_continuous(breaks = c(0, 1)) +\n  labs(x = \"exposure risk\", y = \"infected\", col = \"infected\", subtitle = \"exposure *  avg susceptbility\")\np1 + p2 + plot_layout(guides = \"collect\") + plot_annotation(title = \"Random walker infections\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nNot great, but the infected individuals do have higher exposure risks. Let's see how it worked for the Levy-walker correlated walkers that covered much more ground.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(levy_risk, aes(x=exp_risk, y = infected_es))+\n  geom_point(aes(col=factor(infected_es))) +\n  geom_smooth(method=\"lm\") +\n  scale_y_continuous(breaks = c(0, 1)) +\n  labs(x = \"exposure risk\", y = \"infected\", col = \"infected\", subtitle = \"exposure * susceptbility\")\n\np2 <- ggplot(levy_risk, aes(x=exp_risk, y = infected_e))+\n  geom_point(aes(col=factor(infected_e))) +\n  geom_smooth(method=\"lm\") +\n  scale_y_continuous(breaks = c(0, 1)) +\n  labs(x = \"exposure risk\", y = \"infected\", col = \"infected\", subtitle = \"exposure *  avg susceptbility\")\np1 + p2 + plot_layout(guides = \"collect\") + plot_annotation(title = \"Correlated walker infections\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nCompare predictive accuracy between the models\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_acc_fun <- function(x, infected_type){\n  x$infected <- x %>% dplyr::select(any_of(infected_type)) %>% pull()\n  \n  ## binomial model\n  mod <- glm(infected ~ exp_risk, data = x, family = \"binomial\")\n  ## predicted prob of infection\n  x$pred_prob <- predict(mod, x, type = \"response\")\n  ## if predicted prob >50 say infected\n  x$pred <- 1*(x$pred_prob > .5)\n  x$accurate <- 1*x$infected == x$pred\n  sum(x$accurate) /nrow(x)\n\n}\n```\n:::\n\n\nThe accuracy of the infection predictions should be highest in the random walk individuals with fixed susceptibility (exp_risk \\* avg susceptibility), followed by those with random susceptibility, then correlated walkers with fixed, then random susceptibility.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(walker = c(\"Random\", \"Random\", \"Correlated\", \"Correlated\"),\n           susceptibility = c(\"Fixed\", \"Random\", \"Fixed\", \"Random\"),\n           accuracy = c(pred_acc_fun(rw_risk, \"infected_e\"),\n                        pred_acc_fun(rw_risk, \"infected_es\"),\n                        pred_acc_fun(levy_risk, \"infected_e\"),\n                        pred_acc_fun(levy_risk, \"infected_es\")\n                        )) %>% \n  knitr::kable(title = \"Predictive accuracy of infection probabilities\")\n```\n\n::: {.cell-output-display}\n|walker     |susceptibility | accuracy|\n|:----------|:--------------|--------:|\n|Random     |Fixed          |     0.77|\n|Random     |Random         |     0.76|\n|Correlated |Fixed          |     0.64|\n|Correlated |Random         |     0.65|\n:::\n:::\n\n\n\n\n# Large Simulation\n\nUltimately to see how cumulative exposure risk predicts infection in people, the simulation needs to be run many times. To do that everything from the single simulation needs to be in a single function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulation_fun <- function(n_steps = 1000, n_individuals = 100, susceptibility_range = c(0.7, 0.9),\n                           risk_landscape = riskmap, study_area = aoi, landscape_resistance = resistance, \n                           random_walker = rand.walker, correlated_walker = levy.walker){\n  \n  ## simulate movement\n  ### Random (brownian) walks\n  ## random starting coordinates\n  start_coord <- st_sample(study_area, 100, type = \"random\")\n  start_coord <- st_coordinates(start_coord)\n  \n  ## simulate single state walks of 1000 steps\n  sim.rw <- list()\n  for (i in 1:n_individuals) {\n    ## simulate from location i\n    tmp <- simulate(random_walker, n_steps,\n                    coords = start_coord[i,])\n    ## save results to a list\n    sim.rw[[i]] <- cbind(tmp[,1], tmp[,2])\n  }\n\n  ## make in to sfc lines\n  walks.random <- lapply(sim.rw, st_linestring)\n  walks.random <- st_sf(id = 1:n_individuals, geometry = walks.random) %>% \n    st_set_crs(st_crs(risk_landscape))\n  \n  ### Levy-walker (correlated random)\n  ## new starting coords in areas of low resistance so don't get stuck\n  init = xyFromCell(resistance, sample(which(values(resistance) == 0), 100, replace=T))\n  \n  ## simulate\n  sim.rw <- list()\n  for (i in 1:n_individuals) {\n    ## simulate from location i\n    tmp <- simulate(correlated_walker, n_steps,\n                    resist = raster(resistance),\n                    coords = init[i,])\n    ## save results to a list\n    sim.rw[[i]] <- cbind(tmp[,1], tmp[,2])\n  }\n  \n  ## make in to sfc lines\n  walks.corr <- lapply(sim.rw, st_linestring)\n  walks.corr <- st_sf(id = 1:100, geometry = walks.corr) %>% \n    st_set_crs(st_crs(risk_landscape))\n  \n  ## Calculate cumulative exposure risk/individual\n  ### random walkers\n  indiv.risk.random <- measure_risk(walker = walks.random, riskmap = risk_landscape, nsteps = n_steps)\n  ### correlated random walkers\n  indiv.risk.corr <- measure_risk(walker = walks.corr, riskmap = risk_landscape, nsteps = n_steps)\n  \n  ## assign susceptibility\n  susceptibility = runif(100, susceptibility_range[1], susceptibility_range[2])\n  mean_suscept = mean(susceptibility)\n  \n  ## determine infections\n  ## make a dataframe for the outcomes --- random walkers\n  indiv.risk.random <- cbind(indiv.risk.random,\n                   data.frame( susceptibility = susceptibility)) %>%\n    rowwise() %>% \n    ## predict infections based on exposure risk\n    mutate(infected_es = rbinom(1, 1, exp_risk * susceptibility ), # sum(exp_risk * susceptibility)\n           infected_e = rbinom(1, 1, exp_risk * mean_suscept)) # sum(exposure risk) alone\n  \n  ## make a dataframe for the outcomes --- levy walkers\n  indiv.risk.corr <- cbind(indiv.risk.corr,\n                     data.frame( susceptibility = susceptibility)) %>%\n    rowwise() %>% \n    ## predict infections based on exposure risk\n    mutate(infected_es = rbinom(1, 1, exp_risk * susceptibility ), # sum(exp_risk * susceptibility)\n           infected_e = rbinom(1, 1, exp_risk * mean_suscept)) # sum(exposure risk) alone\n\n  \n  ## output predictive accuracy\n  data.frame(walker = c(\"Random\", \"Random\", \"Correlated\", \"Correlated\"),\n           susceptibility = c(\"Fixed\", \"Random\", \"Fixed\", \"Random\"),\n           accuracy = c(pred_acc_fun(indiv.risk.random, \"infected_e\"),\n                        pred_acc_fun(indiv.risk.random, \"infected_es\"),\n                        pred_acc_fun(indiv.risk.corr, \"infected_e\"),\n                        pred_acc_fun(indiv.risk.corr, \"infected_es\")\n                        ))\n}\n```\n:::\n\n\nCheck that the function works when run one time. By default the simulation uses the riskmap, aoi, resistance raster, and random and levy walker walks set up previously. The default number of steps in each walk is 1000, for 100 individuals, with susceptibility \\[0.7, 0.9\\] as used previously.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## check it works running one time\nsimulation_fun() %>% knitr::kable(title = \"Results of one simulation using the function\")\n```\n\n::: {.cell-output-display}\n|walker     |susceptibility | accuracy|\n|:----------|:--------------|--------:|\n|Random     |Fixed          |     0.79|\n|Random     |Random         |     0.78|\n|Correlated |Fixed          |     0.68|\n|Correlated |Random         |     0.71|\n:::\n:::\n\n\nThen run the function 100 times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## fun the function many times\nlg_sim <- replicate(100, simulation_fun(), simplify = F)\n\n## make the output into one large dataframe\nlg_sim <- bind_rows(lg_sim)\n```\n:::\n\n\nThe distributions of the accuracy of models that use cumulative exposure to predict infection show that as expected random walkers infections are predicted with higher accuracy, and that the effect of variable susceptibility to infection in each individual lower the accuracy of correlated walks more than random walks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## plot the distribution of predictive values between the fix susceptibility random and correlated walks\nlg_sim %>% \n  ggplot(aes(x=accuracy, fill=walker)) +\n  geom_density(adjust =1.5, alpha = 0.7) +\n  scale_fill_brewer(palette = \"Pastel1\")+\n  facet_wrap(~susceptibility, ncol=1)+\n  labs(title = \"Accuracy of Infection Estimates\",\n       subtitle = \"Fixed vs random susceptibility\",\n       fill = \"Walk type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nThe predictive accuracy of the simulations that used the fixed susceptibility values for all individuals (infection is only related to cumulative exposure risk) is significantly higher in random walkers then correlated walkers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## plot the distribution of predictive values between the fix susceptibility random and correlated walks\nlg_sim %>% \n  filter(susceptibility == \"Fixed\") %>% \n  ggplot(aes(x=accuracy, fill=walker)) +\n  geom_density(adjust =1.5, alpha = 0.7) +\n  scale_fill_brewer(palette = \"Pastel1\")+\n  labs(title = \"Accuracy of Infection ~ Cummulative Exposure\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n\n```{.r .cell-code}\n## test if significantly different\nlg_sim %>% \n  filter(susceptibility == \"Fixed\") %>%\n  t.test(accuracy ~ walker, data = ., var.equal = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tTwo Sample t-test\n\ndata:  accuracy by walker\nt = -12.912, df = 198, p-value < 2.2e-16\nalternative hypothesis: true difference in means between group Correlated and group Random is not equal to 0\n95 percent confidence interval:\n -0.09083536 -0.06676464\nsample estimates:\nmean in group Correlated     mean in group Random \n                  0.6973                   0.7761 \n```\n:::\n:::\n\n\nThe same effect is seen in the randomly assigned individual susceptibility random and correlated walkers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## plot the distributions of predictive values between the variable susceptibility random and correlated walks\nlg_sim %>% \n  filter(susceptibility == \"Random\") %>% \n  ggplot(aes(x=accuracy, fill=walker)) +\n  geom_density(adjust =1.5, alpha = 0.7) +\n  scale_fill_brewer(palette = \"Pastel1\")+\n  labs(title = \"Accuracy of Infection ~ Cummulative Exposure*Susceptibility\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n\n```{.r .cell-code}\n## test if significantly different\nlg_sim %>% \n  filter(susceptibility == \"Random\") %>%\n  t.test(accuracy ~ walker, data = ., var.equal = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tTwo Sample t-test\n\ndata:  accuracy by walker\nt = -11.91, df = 198, p-value < 2.2e-16\nalternative hypothesis: true difference in means between group Correlated and group Random is not equal to 0\n95 percent confidence interval:\n -0.088467 -0.063333\nsample estimates:\nmean in group Correlated     mean in group Random \n                  0.6983                   0.7742 \n```\n:::\n:::\n\n\n# Conclusion\n\nTo wrap up the simulation showed that predicting individual infection probability as defined by their cumulative exposure risk, is influence by the amount of noise in that dataset such as we would expect to observe due to variability in individual's susceptibility to infection. Future directions include rerunning this simulation over different susceptibility windows and using predictors that correlate with, but are not the 'real' risk landscape.\n\n# References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}